{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.transformJsonLdDocumentToReactAdminDocument = void 0;\n\nvar _reactAdmin = require(\"react-admin\");\n\nvar _lodash = _interopRequireDefault(require(\"lodash.isplainobject\"));\n\nvar _apiDocParser = require(\"@api-platform/api-doc-parser\");\n\nvar _fetchHydra = _interopRequireDefault(require(\"./fetchHydra\"));\n\nvar _schemaAnalyzer = require(\"./schemaAnalyzer\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nclass ReactAdminDocument {\n  constructor(obj) {\n    Object.assign(this, obj, {\n      originId: obj.id,\n      id: obj['@id']\n    });\n  }\n  /**\n   * @return {string}\n   */\n\n\n  toString() {\n    return `[object ${this.id}]`;\n  }\n\n}\n/**\n * Local cache containing embedded documents.\n * It will be used to prevent useless extra HTTP query if the relation is displayed.\n *\n * @type {Map}\n */\n\n\nconst reactAdminDocumentsCache = new Map();\n/**\n * Transforms a JSON-LD document to a react-admin compatible document.\n *\n * @param {Object} document\n * @param {bool} clone\n * @param {bool} addToCache\n * @param {bool} useEmbedded\n *\n * @return {ReactAdminDocument}\n */\n\nconst transformJsonLdDocumentToReactAdminDocument = function (document) {\n  let clone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  let addToCache = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  let useEmbedded = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n  if (clone) {\n    // deep clone documents\n    document = JSON.parse(JSON.stringify(document));\n  } // The main document is a JSON-LD document, convert it and store it in the cache\n\n\n  if (document['@id']) {\n    document = new ReactAdminDocument(document);\n  } // Replace embedded objects by their IRIs, and store the object itself in the cache to reuse without issuing new HTTP requests.\n\n\n  Object.keys(document).forEach(key => {\n    // to-one\n    if ((0, _lodash.default)(document[key]) && document[key]['@id']) {\n      if (addToCache) {\n        reactAdminDocumentsCache[document[key]['@id']] = transformJsonLdDocumentToReactAdminDocument(document[key], false, false);\n      }\n\n      document[key] = useEmbedded ? document[key] : document[key]['@id'];\n      return;\n    } // to-many\n\n\n    if (Array.isArray(document[key]) && document[key].length && (0, _lodash.default)(document[key][0]) && document[key][0]['@id']) {\n      document[key] = document[key].map(obj => {\n        if (addToCache) {\n          reactAdminDocumentsCache[obj['@id']] = transformJsonLdDocumentToReactAdminDocument(obj, false, false);\n        }\n\n        return useEmbedded ? obj : obj['@id'];\n      });\n    }\n  });\n  return document;\n};\n/**\n * Maps react-admin queries to a Hydra powered REST API\n *\n * @see http://www.hydra-cg.com/\n *\n * @example\n * CREATE   => POST http://my.api.url/posts/123\n * DELETE   => DELETE http://my.api.url/posts/123\n * GET_LIST => GET http://my.api.url/posts\n * GET_MANY => GET http://my.api.url/posts/123, GET http://my.api.url/posts/456, GET http://my.api.url/posts/789\n * GET_ONE  => GET http://my.api.url/posts/123\n * UPDATE   => PUT http://my.api.url/posts/123\n */\n\n\nexports.transformJsonLdDocumentToReactAdminDocument = transformJsonLdDocumentToReactAdminDocument;\n\nvar _default = function (entrypoint) {\n  let httpClient = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _fetchHydra.default;\n  let apiDocumentationParser = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _apiDocParser.parseHydraDocumentation;\n  let useEmbedded = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n  /** @type {Api} */\n  let apiSchema;\n  /**\n   * @param {Resource} resource\n   * @param {Object} data\n   *\n   * @returns {Promise<Object>}\n   */\n\n  const convertReactAdminDataToHydraData = function (resource) {\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const fieldData = [];\n    resource.fields.forEach(_ref => {\n      let {\n        name,\n        reference,\n        normalizeData\n      } = _ref;\n\n      if (!(name in data)) {\n        return;\n      }\n\n      if (reference && data[name] === '') {\n        data[name] = null;\n        return;\n      }\n\n      if (undefined === normalizeData) {\n        return;\n      }\n\n      fieldData[name] = normalizeData(data[name]);\n    });\n    const fieldDataKeys = Object.keys(fieldData);\n    const fieldDataValues = Object.values(fieldData);\n    return Promise.all(fieldDataValues).then(fieldData => {\n      const object = {};\n\n      for (let i = 0; i < fieldDataKeys.length; i++) {\n        object[fieldDataKeys[i]] = fieldData[i];\n      }\n\n      return { ...data,\n        ...object\n      };\n    });\n  };\n  /**\n   * @param {string} resource\n   * @param {Object} data\n   * @param {Object} extraInformation\n   *\n   * @returns {Promise}\n   */\n\n\n  const transformReactAdminDataToRequestBody = (resource, data, extraInformation) => {\n    /** @type {Resource} */\n    const apiResource = apiSchema.resources.find(_ref2 => {\n      let {\n        name\n      } = _ref2;\n      return resource === name;\n    });\n\n    if (undefined === apiResource) {\n      return Promise.resolve(data);\n    }\n\n    return convertReactAdminDataToHydraData(apiResource, data).then(data => {\n      const values = Object.values(data);\n\n      const containFile = element => (0, _lodash.default)(element) && Object.values(element).some(value => value instanceof File);\n\n      if (!extraInformation.hasFileField && !values.some(value => containFile(value))) {\n        return JSON.stringify(data);\n      }\n\n      const body = new FormData();\n      Object.entries(data).map(_ref3 => {\n        let [key, value] = _ref3;\n\n        // React-Admin FileInput format is an object containing a file.\n        if (containFile(value)) {\n          return body.append(key, Object.values(value).find(value => value instanceof File));\n        }\n\n        if ('function' === typeof value.toJSON) {\n          return body.append(key, value.toJSON());\n        }\n\n        if ((0, _lodash.default)(value) || Array.isArray(value)) {\n          return body.append(key, JSON.stringify(value));\n        }\n\n        return body.append(key, value);\n      });\n      return body;\n    });\n  };\n  /**\n   * @param {string} type\n   * @param {string} resource\n   * @param {{\n   *   id: ?string,\n   *   data: ?Object,\n   *   target: ?string,\n   *   filter: ?Object,\n   *   pagination: ?Object,\n   *   sort: ?Object,\n   *   searchParams: ?Object\n   * }} params\n   *\n   * @returns {Object}\n   */\n\n\n  const convertReactAdminRequestToHydraRequest = (type, resource, params) => {\n    const entrypointUrl = new URL(entrypoint, window.location.href);\n    const collectionUrl = new URL(`${entrypoint}/${resource}`, entrypointUrl);\n    const itemUrl = new URL(params.id, entrypointUrl);\n    const searchParams = params.searchParams || {};\n\n    for (const searchParamKey in searchParams) {\n      if (!searchParams.hasOwnProperty(searchParamKey)) {\n        continue;\n      }\n\n      collectionUrl.searchParams.set(searchParamKey, searchParams[searchParamKey]);\n      itemUrl.searchParams.set(searchParamKey, searchParams[searchParamKey]);\n    }\n\n    let extraInformation = {};\n\n    if (params.data && params.data.extraInformation) {\n      extraInformation = params.data.extraInformation;\n      delete params.data.extraInformation;\n    }\n\n    switch (type) {\n      case _reactAdmin.CREATE:\n        return transformReactAdminDataToRequestBody(resource, params.data, extraInformation).then(body => ({\n          options: {\n            body,\n            method: 'POST'\n          },\n          url: collectionUrl\n        }));\n\n      case _reactAdmin.DELETE:\n        return Promise.resolve({\n          options: {\n            method: 'DELETE'\n          },\n          url: itemUrl\n        });\n\n      case _reactAdmin.GET_LIST:\n      case _reactAdmin.GET_MANY_REFERENCE:\n        {\n          const {\n            pagination: {\n              page,\n              perPage\n            },\n            sort: {\n              field,\n              order\n            }\n          } = params;\n          if (order) collectionUrl.searchParams.set(`order[${field}]`, order);\n          if (page) collectionUrl.searchParams.set('page', page);\n          if (perPage) collectionUrl.searchParams.set('itemsPerPage', perPage);\n\n          if (params.filter) {\n            const buildFilterParams = (key, nestedFilter, rootKey) => {\n              const filterValue = nestedFilter[key];\n\n              if (Array.isArray(filterValue)) {\n                filterValue.forEach((arrayFilterValue, index) => {\n                  collectionUrl.searchParams.set(`${rootKey}[${index}]`, arrayFilterValue);\n                });\n                return;\n              }\n\n              if (!(0, _lodash.default)(filterValue)) {\n                collectionUrl.searchParams.set(rootKey, filterValue);\n                return;\n              }\n\n              Object.keys(filterValue).forEach(subKey => {\n                if (rootKey === 'exists' || ['after', 'before', 'strictly_after', 'strictly_before', 'lt', 'gt', 'lte', 'gte', 'between'].includes(subKey)) {\n                  return buildFilterParams(subKey, filterValue, `${rootKey}[${subKey}]`);\n                }\n\n                buildFilterParams(subKey, filterValue, `${rootKey}.${subKey}`);\n              });\n            };\n\n            Object.keys(params.filter).forEach(key => {\n              buildFilterParams(key, params.filter, key);\n            });\n          }\n\n          if (type === _reactAdmin.GET_MANY_REFERENCE && params.target) {\n            collectionUrl.searchParams.set(params.target, params.id);\n          }\n\n          return Promise.resolve({\n            options: {},\n            url: collectionUrl\n          });\n        }\n\n      case _reactAdmin.GET_ONE:\n        return Promise.resolve({\n          options: {},\n          url: itemUrl\n        });\n\n      case _reactAdmin.UPDATE:\n        const updateHttpMethod = extraInformation.hasFileField ? 'POST' : 'PUT';\n        return transformReactAdminDataToRequestBody(resource, params.data, extraInformation).then(body => ({\n          options: {\n            body,\n            method: updateHttpMethod\n          },\n          url: itemUrl\n        }));\n\n      default:\n        throw new Error(`Unsupported fetch action type ${type}`);\n    }\n  };\n  /**\n   * @param {string} resource\n   * @param {Object} data\n   *\n   * @returns {Promise}\n   */\n\n\n  const convertHydraDataToReactAdminData = function (resource) {\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    resource = apiSchema.resources.find(_ref4 => {\n      let {\n        name\n      } = _ref4;\n      return resource === name;\n    });\n\n    if (undefined === resource) {\n      return Promise.resolve(data);\n    }\n\n    const fieldData = {};\n    resource.fields.forEach(_ref5 => {\n      let {\n        name,\n        denormalizeData\n      } = _ref5;\n\n      if (!(name in data) || undefined === denormalizeData) {\n        return;\n      }\n\n      fieldData[name] = denormalizeData(data[name]);\n    });\n    const fieldDataKeys = Object.keys(fieldData);\n    const fieldDataValues = Object.values(fieldData);\n    return Promise.all(fieldDataValues).then(fieldData => {\n      const object = {};\n\n      for (let i = 0; i < fieldDataKeys.length; i++) {\n        object[fieldDataKeys[i]] = fieldData[i];\n      }\n\n      return { ...data,\n        ...object\n      };\n    });\n  };\n  /**\n   * @param {string} type\n   * @param {string} resource\n   * @param {{ id: ?string }} params\n   * @param {Object} response\n   *\n   * @returns {Promise}\n   */\n\n\n  const convertHydraResponseToReactAdminResponse = (type, resource, params, response) => {\n    switch (type) {\n      case _reactAdmin.GET_LIST:\n      case _reactAdmin.GET_MANY_REFERENCE:\n        // TODO: support other prefixes than \"hydra:\"\n        return Promise.resolve(response.json['hydra:member'].map(document => transformJsonLdDocumentToReactAdminDocument(document, true, true, useEmbedded))).then(data => Promise.all(data.map(data => convertHydraDataToReactAdminData(resource, data)))).then(data => ({\n          data,\n          total: response.json.hasOwnProperty('hydra:totalItems') ? response.json['hydra:totalItems'] : response.json['hydra:view'] ? response.json['hydra:view']['hydra:next'] ? -2 // there is a next page\n          : -1 // no next page\n          : -3 // no information\n\n        }));\n\n      case _reactAdmin.DELETE:\n        return Promise.resolve({\n          data: {\n            id: params.id\n          }\n        });\n\n      default:\n        return Promise.resolve(transformJsonLdDocumentToReactAdminDocument(response.json, true, true, useEmbedded)).then(data => convertHydraDataToReactAdminData(resource, data)).then(data => ({\n          data\n        }));\n    }\n  };\n  /**\n   * @param {string} type\n   * @param {string} resource\n   * @param {{\n   *   id: ?string,\n   *   data: ?Object,\n   *   target: ?string,\n   *   filter: ?Object,\n   *   pagination: ?Object,\n   *   sort: ?Object,\n   *   searchParams: ?Object\n   * }} params\n   *\n   * @returns {Promise}\n   */\n\n\n  const fetchApi = (type, resource, params) => convertReactAdminRequestToHydraRequest(type, resource, params).then(_ref6 => {\n    let {\n      url,\n      options\n    } = _ref6;\n    return httpClient(url, options);\n  }).then(response => convertHydraResponseToReactAdminResponse(type, resource, params, response));\n  /**\n   * @param {string} resource\n   *\n   * @returns {Promise<boolean>}\n   */\n\n\n  const hasIdSearchFilter = resource => {\n    const schema = apiSchema.resources.find(r => r.name === resource);\n    return (0, _schemaAnalyzer.resolveSchemaParameters)(schema).then(parameters => parameters.map(filter => filter.variable).includes('id'));\n  };\n\n  return {\n    getList: (resource, params) => fetchApi(_reactAdmin.GET_LIST, resource, params),\n    getOne: (resource, params) => fetchApi(_reactAdmin.GET_ONE, resource, params),\n    getMany: (resource, params) => {\n      return hasIdSearchFilter(resource).then(result => {\n        // Hydra doesn't handle MANY requests but if a search filter for the id is available, it is used.\n        if (result) {\n          return fetchApi(_reactAdmin.GET_LIST, resource, {\n            pagination: {},\n            sort: {},\n            filter: {\n              id: params.ids\n            }\n          });\n        } // Else fallback to calling the ONE request n times instead.\n\n\n        return Promise.all(params.ids.map(id => reactAdminDocumentsCache[id] ? Promise.resolve({\n          data: reactAdminDocumentsCache[id]\n        }) : fetchApi(_reactAdmin.GET_ONE, resource, {\n          id\n        }))).then(responses => ({\n          data: responses.map(_ref7 => {\n            let {\n              data\n            } = _ref7;\n            return data;\n          })\n        }));\n      });\n    },\n    getManyReference: (resource, params) => fetchApi(_reactAdmin.GET_MANY_REFERENCE, resource, params),\n    update: (resource, params) => fetchApi(_reactAdmin.UPDATE, resource, params),\n    updateMany: (resource, params) => Promise.all(params.ids.map(id => fetchApi(_reactAdmin.UPDATE, resource, { ...params,\n      id\n    }))).then(() => ({\n      data: []\n    })),\n    create: (resource, params) => fetchApi(_reactAdmin.CREATE, resource, params),\n    delete: (resource, params) => fetchApi(_reactAdmin.DELETE, resource, params),\n    deleteMany: (resource, params) => Promise.all(params.ids.map(id => fetchApi(_reactAdmin.DELETE, resource, {\n      id\n    }))).then(() => ({\n      data: []\n    })),\n    introspect: () => apiSchema ? Promise.resolve({\n      data: apiSchema\n    }) : apiDocumentationParser(entrypoint).then(_ref8 => {\n      let {\n        api,\n        customRoutes = []\n      } = _ref8;\n\n      if (api.resources.length > 0) {\n        apiSchema = api;\n      }\n\n      return {\n        data: api,\n        customRoutes\n      };\n    }).catch(err => {\n      let {\n        status,\n        message,\n        error\n      } = err; // Note that the `api-doc-parser` rejects with a non-standard error object hence the check\n\n      if (error && error.message) {\n        message = error.message;\n      }\n\n      throw new Error('Cannot fetch API documentation:\\n' + (message ? `${message}\\nHave you verified that CORS is correctly configured in your API?\\n` : '') + (status ? `Status: ${status}` : ''));\n    })\n  };\n};\n\nexports.default = _default;","map":{"version":3,"sources":["C:/newproject/bookshop-api/myadmin/node_modules/@api-platform/admin/lib/hydra/dataProvider.js"],"names":["Object","defineProperty","exports","value","default","transformJsonLdDocumentToReactAdminDocument","_reactAdmin","require","_lodash","_interopRequireDefault","_apiDocParser","_fetchHydra","_schemaAnalyzer","obj","__esModule","ReactAdminDocument","constructor","assign","originId","id","toString","reactAdminDocumentsCache","Map","document","clone","addToCache","useEmbedded","JSON","parse","stringify","keys","forEach","key","Array","isArray","length","map","_default","entrypoint","httpClient","apiDocumentationParser","parseHydraDocumentation","apiSchema","convertReactAdminDataToHydraData","resource","data","fieldData","fields","name","reference","normalizeData","undefined","fieldDataKeys","fieldDataValues","values","Promise","all","then","object","i","transformReactAdminDataToRequestBody","extraInformation","apiResource","resources","find","resolve","containFile","element","some","File","hasFileField","body","FormData","entries","append","toJSON","convertReactAdminRequestToHydraRequest","type","params","entrypointUrl","URL","window","location","href","collectionUrl","itemUrl","searchParams","searchParamKey","hasOwnProperty","set","CREATE","options","method","url","DELETE","GET_LIST","GET_MANY_REFERENCE","pagination","page","perPage","sort","field","order","filter","buildFilterParams","nestedFilter","rootKey","filterValue","arrayFilterValue","index","subKey","includes","target","GET_ONE","UPDATE","updateHttpMethod","Error","convertHydraDataToReactAdminData","denormalizeData","convertHydraResponseToReactAdminResponse","response","json","total","fetchApi","hasIdSearchFilter","schema","r","resolveSchemaParameters","parameters","variable","getList","getOne","getMany","result","ids","responses","getManyReference","update","updateMany","create","delete","deleteMany","introspect","api","customRoutes","catch","err","status","message","error"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.transformJsonLdDocumentToReactAdminDocument = void 0;\n\nvar _reactAdmin = require(\"react-admin\");\n\nvar _lodash = _interopRequireDefault(require(\"lodash.isplainobject\"));\n\nvar _apiDocParser = require(\"@api-platform/api-doc-parser\");\n\nvar _fetchHydra = _interopRequireDefault(require(\"./fetchHydra\"));\n\nvar _schemaAnalyzer = require(\"./schemaAnalyzer\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass ReactAdminDocument {\n  constructor(obj) {\n    Object.assign(this, obj, {\n      originId: obj.id,\n      id: obj['@id']\n    });\n  }\n  /**\n   * @return {string}\n   */\n\n\n  toString() {\n    return `[object ${this.id}]`;\n  }\n\n}\n/**\n * Local cache containing embedded documents.\n * It will be used to prevent useless extra HTTP query if the relation is displayed.\n *\n * @type {Map}\n */\n\n\nconst reactAdminDocumentsCache = new Map();\n/**\n * Transforms a JSON-LD document to a react-admin compatible document.\n *\n * @param {Object} document\n * @param {bool} clone\n * @param {bool} addToCache\n * @param {bool} useEmbedded\n *\n * @return {ReactAdminDocument}\n */\n\nconst transformJsonLdDocumentToReactAdminDocument = (document, clone = true, addToCache = true, useEmbedded = false) => {\n  if (clone) {\n    // deep clone documents\n    document = JSON.parse(JSON.stringify(document));\n  } // The main document is a JSON-LD document, convert it and store it in the cache\n\n\n  if (document['@id']) {\n    document = new ReactAdminDocument(document);\n  } // Replace embedded objects by their IRIs, and store the object itself in the cache to reuse without issuing new HTTP requests.\n\n\n  Object.keys(document).forEach(key => {\n    // to-one\n    if ((0, _lodash.default)(document[key]) && document[key]['@id']) {\n      if (addToCache) {\n        reactAdminDocumentsCache[document[key]['@id']] = transformJsonLdDocumentToReactAdminDocument(document[key], false, false);\n      }\n\n      document[key] = useEmbedded ? document[key] : document[key]['@id'];\n      return;\n    } // to-many\n\n\n    if (Array.isArray(document[key]) && document[key].length && (0, _lodash.default)(document[key][0]) && document[key][0]['@id']) {\n      document[key] = document[key].map(obj => {\n        if (addToCache) {\n          reactAdminDocumentsCache[obj['@id']] = transformJsonLdDocumentToReactAdminDocument(obj, false, false);\n        }\n\n        return useEmbedded ? obj : obj['@id'];\n      });\n    }\n  });\n  return document;\n};\n/**\n * Maps react-admin queries to a Hydra powered REST API\n *\n * @see http://www.hydra-cg.com/\n *\n * @example\n * CREATE   => POST http://my.api.url/posts/123\n * DELETE   => DELETE http://my.api.url/posts/123\n * GET_LIST => GET http://my.api.url/posts\n * GET_MANY => GET http://my.api.url/posts/123, GET http://my.api.url/posts/456, GET http://my.api.url/posts/789\n * GET_ONE  => GET http://my.api.url/posts/123\n * UPDATE   => PUT http://my.api.url/posts/123\n */\n\n\nexports.transformJsonLdDocumentToReactAdminDocument = transformJsonLdDocumentToReactAdminDocument;\n\nvar _default = (entrypoint, httpClient = _fetchHydra.default, apiDocumentationParser = _apiDocParser.parseHydraDocumentation, useEmbedded = false // remove this parameter for 3.0 (as true)\n) => {\n  /** @type {Api} */\n  let apiSchema;\n  /**\n   * @param {Resource} resource\n   * @param {Object} data\n   *\n   * @returns {Promise<Object>}\n   */\n\n  const convertReactAdminDataToHydraData = (resource, data = {}) => {\n    const fieldData = [];\n    resource.fields.forEach(({\n      name,\n      reference,\n      normalizeData\n    }) => {\n      if (!(name in data)) {\n        return;\n      }\n\n      if (reference && data[name] === '') {\n        data[name] = null;\n        return;\n      }\n\n      if (undefined === normalizeData) {\n        return;\n      }\n\n      fieldData[name] = normalizeData(data[name]);\n    });\n    const fieldDataKeys = Object.keys(fieldData);\n    const fieldDataValues = Object.values(fieldData);\n    return Promise.all(fieldDataValues).then(fieldData => {\n      const object = {};\n\n      for (let i = 0; i < fieldDataKeys.length; i++) {\n        object[fieldDataKeys[i]] = fieldData[i];\n      }\n\n      return { ...data,\n        ...object\n      };\n    });\n  };\n  /**\n   * @param {string} resource\n   * @param {Object} data\n   * @param {Object} extraInformation\n   *\n   * @returns {Promise}\n   */\n\n\n  const transformReactAdminDataToRequestBody = (resource, data, extraInformation) => {\n    /** @type {Resource} */\n    const apiResource = apiSchema.resources.find(({\n      name\n    }) => resource === name);\n\n    if (undefined === apiResource) {\n      return Promise.resolve(data);\n    }\n\n    return convertReactAdminDataToHydraData(apiResource, data).then(data => {\n      const values = Object.values(data);\n\n      const containFile = element => (0, _lodash.default)(element) && Object.values(element).some(value => value instanceof File);\n\n      if (!extraInformation.hasFileField && !values.some(value => containFile(value))) {\n        return JSON.stringify(data);\n      }\n\n      const body = new FormData();\n      Object.entries(data).map(([key, value]) => {\n        // React-Admin FileInput format is an object containing a file.\n        if (containFile(value)) {\n          return body.append(key, Object.values(value).find(value => value instanceof File));\n        }\n\n        if ('function' === typeof value.toJSON) {\n          return body.append(key, value.toJSON());\n        }\n\n        if ((0, _lodash.default)(value) || Array.isArray(value)) {\n          return body.append(key, JSON.stringify(value));\n        }\n\n        return body.append(key, value);\n      });\n      return body;\n    });\n  };\n  /**\n   * @param {string} type\n   * @param {string} resource\n   * @param {{\n   *   id: ?string,\n   *   data: ?Object,\n   *   target: ?string,\n   *   filter: ?Object,\n   *   pagination: ?Object,\n   *   sort: ?Object,\n   *   searchParams: ?Object\n   * }} params\n   *\n   * @returns {Object}\n   */\n\n\n  const convertReactAdminRequestToHydraRequest = (type, resource, params) => {\n    const entrypointUrl = new URL(entrypoint, window.location.href);\n    const collectionUrl = new URL(`${entrypoint}/${resource}`, entrypointUrl);\n    const itemUrl = new URL(params.id, entrypointUrl);\n    const searchParams = params.searchParams || {};\n\n    for (const searchParamKey in searchParams) {\n      if (!searchParams.hasOwnProperty(searchParamKey)) {\n        continue;\n      }\n\n      collectionUrl.searchParams.set(searchParamKey, searchParams[searchParamKey]);\n      itemUrl.searchParams.set(searchParamKey, searchParams[searchParamKey]);\n    }\n\n    let extraInformation = {};\n\n    if (params.data && params.data.extraInformation) {\n      extraInformation = params.data.extraInformation;\n      delete params.data.extraInformation;\n    }\n\n    switch (type) {\n      case _reactAdmin.CREATE:\n        return transformReactAdminDataToRequestBody(resource, params.data, extraInformation).then(body => ({\n          options: {\n            body,\n            method: 'POST'\n          },\n          url: collectionUrl\n        }));\n\n      case _reactAdmin.DELETE:\n        return Promise.resolve({\n          options: {\n            method: 'DELETE'\n          },\n          url: itemUrl\n        });\n\n      case _reactAdmin.GET_LIST:\n      case _reactAdmin.GET_MANY_REFERENCE:\n        {\n          const {\n            pagination: {\n              page,\n              perPage\n            },\n            sort: {\n              field,\n              order\n            }\n          } = params;\n          if (order) collectionUrl.searchParams.set(`order[${field}]`, order);\n          if (page) collectionUrl.searchParams.set('page', page);\n          if (perPage) collectionUrl.searchParams.set('itemsPerPage', perPage);\n\n          if (params.filter) {\n            const buildFilterParams = (key, nestedFilter, rootKey) => {\n              const filterValue = nestedFilter[key];\n\n              if (Array.isArray(filterValue)) {\n                filterValue.forEach((arrayFilterValue, index) => {\n                  collectionUrl.searchParams.set(`${rootKey}[${index}]`, arrayFilterValue);\n                });\n                return;\n              }\n\n              if (!(0, _lodash.default)(filterValue)) {\n                collectionUrl.searchParams.set(rootKey, filterValue);\n                return;\n              }\n\n              Object.keys(filterValue).forEach(subKey => {\n                if (rootKey === 'exists' || ['after', 'before', 'strictly_after', 'strictly_before', 'lt', 'gt', 'lte', 'gte', 'between'].includes(subKey)) {\n                  return buildFilterParams(subKey, filterValue, `${rootKey}[${subKey}]`);\n                }\n\n                buildFilterParams(subKey, filterValue, `${rootKey}.${subKey}`);\n              });\n            };\n\n            Object.keys(params.filter).forEach(key => {\n              buildFilterParams(key, params.filter, key);\n            });\n          }\n\n          if (type === _reactAdmin.GET_MANY_REFERENCE && params.target) {\n            collectionUrl.searchParams.set(params.target, params.id);\n          }\n\n          return Promise.resolve({\n            options: {},\n            url: collectionUrl\n          });\n        }\n\n      case _reactAdmin.GET_ONE:\n        return Promise.resolve({\n          options: {},\n          url: itemUrl\n        });\n\n      case _reactAdmin.UPDATE:\n        const updateHttpMethod = extraInformation.hasFileField ? 'POST' : 'PUT';\n        return transformReactAdminDataToRequestBody(resource, params.data, extraInformation).then(body => ({\n          options: {\n            body,\n            method: updateHttpMethod\n          },\n          url: itemUrl\n        }));\n\n      default:\n        throw new Error(`Unsupported fetch action type ${type}`);\n    }\n  };\n  /**\n   * @param {string} resource\n   * @param {Object} data\n   *\n   * @returns {Promise}\n   */\n\n\n  const convertHydraDataToReactAdminData = (resource, data = {}) => {\n    resource = apiSchema.resources.find(({\n      name\n    }) => resource === name);\n\n    if (undefined === resource) {\n      return Promise.resolve(data);\n    }\n\n    const fieldData = {};\n    resource.fields.forEach(({\n      name,\n      denormalizeData\n    }) => {\n      if (!(name in data) || undefined === denormalizeData) {\n        return;\n      }\n\n      fieldData[name] = denormalizeData(data[name]);\n    });\n    const fieldDataKeys = Object.keys(fieldData);\n    const fieldDataValues = Object.values(fieldData);\n    return Promise.all(fieldDataValues).then(fieldData => {\n      const object = {};\n\n      for (let i = 0; i < fieldDataKeys.length; i++) {\n        object[fieldDataKeys[i]] = fieldData[i];\n      }\n\n      return { ...data,\n        ...object\n      };\n    });\n  };\n  /**\n   * @param {string} type\n   * @param {string} resource\n   * @param {{ id: ?string }} params\n   * @param {Object} response\n   *\n   * @returns {Promise}\n   */\n\n\n  const convertHydraResponseToReactAdminResponse = (type, resource, params, response) => {\n    switch (type) {\n      case _reactAdmin.GET_LIST:\n      case _reactAdmin.GET_MANY_REFERENCE:\n        // TODO: support other prefixes than \"hydra:\"\n        return Promise.resolve(response.json['hydra:member'].map(document => transformJsonLdDocumentToReactAdminDocument(document, true, true, useEmbedded))).then(data => Promise.all(data.map(data => convertHydraDataToReactAdminData(resource, data)))).then(data => ({\n          data,\n          total: response.json.hasOwnProperty('hydra:totalItems') ? response.json['hydra:totalItems'] : response.json['hydra:view'] ? response.json['hydra:view']['hydra:next'] ? -2 // there is a next page\n          : -1 // no next page\n          : -3 // no information\n\n        }));\n\n      case _reactAdmin.DELETE:\n        return Promise.resolve({\n          data: {\n            id: params.id\n          }\n        });\n\n      default:\n        return Promise.resolve(transformJsonLdDocumentToReactAdminDocument(response.json, true, true, useEmbedded)).then(data => convertHydraDataToReactAdminData(resource, data)).then(data => ({\n          data\n        }));\n    }\n  };\n  /**\n   * @param {string} type\n   * @param {string} resource\n   * @param {{\n   *   id: ?string,\n   *   data: ?Object,\n   *   target: ?string,\n   *   filter: ?Object,\n   *   pagination: ?Object,\n   *   sort: ?Object,\n   *   searchParams: ?Object\n   * }} params\n   *\n   * @returns {Promise}\n   */\n\n\n  const fetchApi = (type, resource, params) => convertReactAdminRequestToHydraRequest(type, resource, params).then(({\n    url,\n    options\n  }) => httpClient(url, options)).then(response => convertHydraResponseToReactAdminResponse(type, resource, params, response));\n  /**\n   * @param {string} resource\n   *\n   * @returns {Promise<boolean>}\n   */\n\n\n  const hasIdSearchFilter = resource => {\n    const schema = apiSchema.resources.find(r => r.name === resource);\n    return (0, _schemaAnalyzer.resolveSchemaParameters)(schema).then(parameters => parameters.map(filter => filter.variable).includes('id'));\n  };\n\n  return {\n    getList: (resource, params) => fetchApi(_reactAdmin.GET_LIST, resource, params),\n    getOne: (resource, params) => fetchApi(_reactAdmin.GET_ONE, resource, params),\n    getMany: (resource, params) => {\n      return hasIdSearchFilter(resource).then(result => {\n        // Hydra doesn't handle MANY requests but if a search filter for the id is available, it is used.\n        if (result) {\n          return fetchApi(_reactAdmin.GET_LIST, resource, {\n            pagination: {},\n            sort: {},\n            filter: {\n              id: params.ids\n            }\n          });\n        } // Else fallback to calling the ONE request n times instead.\n\n\n        return Promise.all(params.ids.map(id => reactAdminDocumentsCache[id] ? Promise.resolve({\n          data: reactAdminDocumentsCache[id]\n        }) : fetchApi(_reactAdmin.GET_ONE, resource, {\n          id\n        }))).then(responses => ({\n          data: responses.map(({\n            data\n          }) => data)\n        }));\n      });\n    },\n    getManyReference: (resource, params) => fetchApi(_reactAdmin.GET_MANY_REFERENCE, resource, params),\n    update: (resource, params) => fetchApi(_reactAdmin.UPDATE, resource, params),\n    updateMany: (resource, params) => Promise.all(params.ids.map(id => fetchApi(_reactAdmin.UPDATE, resource, { ...params,\n      id\n    }))).then(() => ({\n      data: []\n    })),\n    create: (resource, params) => fetchApi(_reactAdmin.CREATE, resource, params),\n    delete: (resource, params) => fetchApi(_reactAdmin.DELETE, resource, params),\n    deleteMany: (resource, params) => Promise.all(params.ids.map(id => fetchApi(_reactAdmin.DELETE, resource, {\n      id\n    }))).then(() => ({\n      data: []\n    })),\n    introspect: () => apiSchema ? Promise.resolve({\n      data: apiSchema\n    }) : apiDocumentationParser(entrypoint).then(({\n      api,\n      customRoutes = []\n    }) => {\n      if (api.resources.length > 0) {\n        apiSchema = api;\n      }\n\n      return {\n        data: api,\n        customRoutes\n      };\n    }).catch(err => {\n      let {\n        status,\n        message,\n        error\n      } = err; // Note that the `api-doc-parser` rejects with a non-standard error object hence the check\n\n      if (error && error.message) {\n        message = error.message;\n      }\n\n      throw new Error('Cannot fetch API documentation:\\n' + (message ? `${message}\\nHave you verified that CORS is correctly configured in your API?\\n` : '') + (status ? `Status: ${status}` : ''));\n    })\n  };\n};\n\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}