"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.IntrospectedInputGuesser = void 0;

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _reactAdmin = require("react-admin");

var _reactFinalForm = require("react-final-form");

var _Introspecter = _interopRequireDefault(require("./Introspecter"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

const IntrospectedInputGuesser = ({
  fields,
  readableFields,
  writableFields,
  schema,
  schemaAnalyzer,
  validate,
  ...props
}) => {
  const translate = (0, _reactAdmin.useTranslate)();
  const form = (0, _reactFinalForm.useForm)(); // Pause the validation while the Final Form field is registered to prevent a form state desynchronization bug when using async validators.
  // Since the field is not registered directly because of the introspection, Final Form is using the previous form state (without the field) when notifying after the async validation done during the registration.
  // See also https://github.com/final-form/react-final-form/issues/780.

  form.pauseValidation();
  (0, _react.useEffect)(() => {
    form.resumeValidation();
  });
  const field = fields.find(({
    name
  }) => name === props.source);

  if (!field) {
    console.error(`Field ${props.source} not present inside API description for the resource ${props.resource}`);
    return /*#__PURE__*/_react.default.createElement(_react.Fragment, null);
  }

  const guessedValidate = !validate && field.required ? [(0, _reactAdmin.required)()] : validate;

  if (null !== field.reference) {
    if (1 === field.maxCardinality) {
      return /*#__PURE__*/_react.default.createElement(_reactAdmin.ReferenceInput, _extends({
        key: field.name,
        reference: field.reference.name,
        source: field.name,
        validate: guessedValidate
      }, props, {
        allowEmpty: true
      }), /*#__PURE__*/_react.default.createElement(_reactAdmin.SelectInput, {
        optionText: schemaAnalyzer.getFieldNameFromSchema(field.reference)
      }));
    } // Not needed after React-Admin >= 3.10.4 (see https://github.com/marmelab/react-admin/pull/5606).


    const translatedLabel = translate(...(0, _reactAdmin.getFieldLabelTranslationArgs)({
      resource: props.resource,
      source: field.name
    }));
    return /*#__PURE__*/_react.default.createElement(_reactAdmin.ReferenceArrayInput, _extends({
      key: field.name,
      label: translatedLabel,
      reference: field.reference.name,
      source: field.name,
      validate: guessedValidate
    }, props, {
      allowEmpty: true
    }), /*#__PURE__*/_react.default.createElement(_reactAdmin.SelectArrayInput, {
      optionText: schemaAnalyzer.getFieldNameFromSchema(field.reference)
    }));
  }

  const fieldType = schemaAnalyzer.getFieldType(field);

  if (fieldType === 'id') {
    const prefix = `/${props.resource}/`;

    props.format = value => {
      return value && 0 === value.indexOf(prefix) ? value.substr(prefix.length) : value;
    };

    props.parse = value => {
      return -1 !== value.indexOf(prefix) ? prefix + value : value;
    };
  }

  const formatEmbedded = value => JSON.stringify(value);

  const parseEmbedded = value => JSON.parse(value);

  if (null !== field.embedded && 1 === field.maxCardinality) {
    props.format = formatEmbedded;
    props.parse = parseEmbedded;
  }

  switch (fieldType) {
    case 'array':
      let textInputFormat = value => value;

      let textInputParse = value => value;

      if (null !== field.embedded && 1 !== field.maxCardinality) {
        textInputFormat = formatEmbedded;
        textInputParse = parseEmbedded;
      }

      return /*#__PURE__*/_react.default.createElement(_reactAdmin.ArrayInput, _extends({
        key: field.name,
        source: field.name,
        validate: guessedValidate
      }, props), /*#__PURE__*/_react.default.createElement(_reactAdmin.SimpleFormIterator, null, /*#__PURE__*/_react.default.createElement(_reactAdmin.TextInput, {
        format: textInputFormat,
        parse: textInputParse
      })));

    case 'integer':
      return /*#__PURE__*/_react.default.createElement(_reactAdmin.NumberInput, _extends({
        key: field.name,
        source: field.name,
        validate: guessedValidate
      }, props));

    case 'float':
      return /*#__PURE__*/_react.default.createElement(_reactAdmin.NumberInput, _extends({
        key: field.name,
        source: field.name,
        step: "0.1",
        validate: guessedValidate
      }, props));

    case 'boolean':
      return /*#__PURE__*/_react.default.createElement(_reactAdmin.BooleanInput, _extends({
        key: field.name,
        source: field.name,
        validate: guessedValidate
      }, props));

    case 'date':
      return /*#__PURE__*/_react.default.createElement(_reactAdmin.DateInput, _extends({
        key: field.name,
        source: field.name,
        validate: guessedValidate
      }, props));

    case 'dateTime':
      return /*#__PURE__*/_react.default.createElement(_reactAdmin.DateTimeInput, _extends({
        key: field.name,
        source: field.name,
        validate: guessedValidate
      }, props));

    default:
      return /*#__PURE__*/_react.default.createElement(_reactAdmin.TextInput, _extends({
        key: field.name,
        source: field.name,
        validate: guessedValidate
      }, props));
  }
};

exports.IntrospectedInputGuesser = IntrospectedInputGuesser;

const InputGuesser = props => /*#__PURE__*/_react.default.createElement(_Introspecter.default, _extends({
  component: IntrospectedInputGuesser,
  includeDeprecated: true
}, props));

InputGuesser.propTypes = {
  source: _propTypes.default.string.isRequired
};
var _default = InputGuesser;
exports.default = _default;